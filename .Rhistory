## loop in levels
for (i in groupLevels) {
inds <- which(group == i)
nameGroupLevel <- groupname[inds]
simMatI <- similarityMatrix[inds, inds]
hClust <- amap::hcluster(simMatI, method = "spearman")
## write order within groups to orderNew
orderNew[inds] <- inds[hClust$order]
}
}
groupNameNew <- groupname[orderNew]
groupNameNewSplit <- strsplit(groupNameNew, "_")
## count from 1 to length(x) of unique groups
groupNew <- unlist(lapply(groupNameNewSplit, "[", 1))
## length of each group
groupNew_l <- as.vector(table(groupNew))
## create counter
counter <- lapply(1:length(groupNew_l),
function (x) sprintf("%04d", 1:groupNew_l[x]))
counter <- unlist(counter)
groupNameNew <- lapply(1:length(groupname),
function (x) paste(groupNameNewSplit[[x]][1],
counter[x], groupNameNewSplit[[x]][2], sep="_"))
groupNameNew <- unlist(groupNameNew)
if (order == "clustering") {
## reorder due to clustering
orderNew <- order(groupNameNew)
groupNameNew <- groupNameNew[orderNew]
}
simM <- similarityMatrix[orderNew, orderNew]
colnames(simM) <- rownames(simM) <- groupNameNew
return(simM)
}
##hClustMSP_cut <- cutree(hClustMSP, h = 100)
similarityMat <- createSimilarityMatrix(binnedMSP)
simMatRT <- createOrderedSimMat(similarityMat, order = "retentionT")
linkMatRT <- createLinkMatrix(simMatRT, 0.75)
linkMat <- createLinkMatrix(similarityMat, 0.75)
getLinkMatrixIndices( "att_364.9163804/62.1957208", linkMat)
getLinkMatrixIndices( "att_0007_364.9163804/62.1957208", linkMatRT)
linkMatRT[c(28:32),]
linkMat[c(206,218:221),]
simMatClust <- createOrderedSimMat(similarityMat, order = "clustering")
linkMatClust <- createLinkMatrix(simMatClust, 0.75)
colnames(simMatClust)
getLinkMatrixIndices( "att_0025_364.9163804/62.1957208" , linkMatClust)
getLinkMatrixIndices( "att_0025_364.9163804/62.1957208" , linkMatClust)
#' @export
createOrderedSimMat <- function(similarityMatrix, order = c("retentionTime","mz", "clustering")) {
order <- match.arg(order)
groupname <- rownames(similarityMatrix)
## get group and name from groupname
## groupname is a vector containing information about group and name,
## where group is the first element and name the last element separated by _
group <- lapply(strsplit(groupname, split = "_"), "[", 1)
group <- unlist(group)
name <- lapply(strsplit(groupname, split = "_"), function (x) x[length(x)])
name <- unlist(name)
## retentionTime
if (order == "retentionTime") {
nameMZRT <- strsplit(name, split = "/")
rt <- lapply(nameMZRT, "[[", 2)
rt <- unlist(rt)
rt <- as.numeric(rt)
orderNew <- order(group, rt)
}
## mz
if (order == "mz") {
nameMZRT <- strsplit(name, split = "/")
mz <- lapply(nameMZRT, "[[", 1)
mz <- unlist(mz)
mz <- as.numeric(mz)
orderNew <- order(group, mz)
}
## clustering
if (order == "clustering") {
orderNew <- numeric(length = length(groupname))
groupLevels <- sort(unique(group))
## loop in levels
for (i in groupLevels) {
inds <- which(group == i)
nameGroupLevel <- groupname[inds]
simMatI <- similarityMatrix[inds, inds]
hClust <- amap::hcluster(simMatI, method = "spearman")
## write order within groups to orderNew
orderNew[inds] <- inds[hClust$order]
}
}
groupNameNew <- groupname[orderNew]
groupNameNewSplit <- strsplit(groupNameNew, "_")
## count from 1 to length(x) of unique groups
groupNew <- unlist(lapply(groupNameNewSplit, "[", 1))
## length of each group
groupNew_l <- as.vector(table(groupNew))
## create counter
counter <- lapply(1:length(groupNew_l),
function (x) sprintf("%04d", 1:groupNew_l[x]))
counter <- unlist(counter)
groupNameNew <- lapply(1:length(groupname),
function (x) paste(groupNameNewSplit[[x]][1],
counter[x], groupNameNewSplit[[x]][2], sep="_"))
groupNameNew <- unlist(groupNameNew)
## if (order == "clustering") {
##     ## reorder due to clustering
##    orderNew <- order(groupNameNew)
##    groupNameNew <- groupNameNew[orderNew]
## }
simM <- similarityMatrix[orderNew, orderNew]
colnames(simM) <- rownames(simM) <- groupNameNew
return(simM)
}
getLinkMatrixIndices( "att_0025_364.9163804/62.1957208" , linkMatClust)
simMatRT <- createOrderedSimMat(similarityMat, order = "retentionT")
linkMatRT <- createLinkMatrix(simMatRT, 0.75)
linkMat <- createLinkMatrix(similarityMat, 0.75)
simMatClust <- createOrderedSimMat(similarityMat, order = "clustering")
linkMatClust <- createLinkMatrix(simMatClust, 0.75)
getLinkMatrixIndices( "att_364.9163804/62.1957208", linkMat)
getLinkMatrixIndices( "att_0007_364.9163804/62.1957208", linkMatRT)
getLinkMatrixIndices( "att_0025_364.9163804/62.1957208" , linkMatClust)
linkMatClust[c(86, 91:94),]
shinyCircos(similarityMatrix = similarityMat, msp = finalMSP)
printInformationHover(groupname, finalMSP, 1, lMatIndHover = c(1,2,3), linkMat, similarityMat)
getLinkMatrixIndices( "att_364.9163804/62.1957208", linkMat)
printInformationHover(groupname, finalMSP, 1, lMatIndHover = c(206, 218:221), linkMat, similarityMat)
printInformationHover(groupname, finalMSP, 7, lMatIndHover = c(206, 218:221), linkMat, similarityMat)
groupname[7]
linkMat
getLinkMatrixIndices( "att_0025_364.9163804/62.1957208" , linkMatClust)
getLinkMatrixIndices( "att_364.9163804/62.1957208", linkMat)
linkMat <- createLinkMatrix(similarityMat, 0.75)
printInformationHover(groupname, finalMSP, ind = 7, lMatIndHover = c(206, 218:221), linkMat, similarityMat)
groupname
finalMSP
colnames(similarityMat)
printInformationHover(groupname, finalMSP, ind = 7, lMatIndHover = c(206, 218:221), linkMat, similarityMat)
similarityMatrix <- similarityMat
printInformationHover(groupname, NULLP, ind = 7, lMatIndHover = c(206, 218:221), linkMat, similarityMat)
printInformationHover(groupname, NULL, ind = 7, lMatIndHover = c(206, 218:221), linkMat, similarityMat)
printInformationHover(groupname, finalMSP, ind = 7, lMatIndHover = c(206, 218:221), linkMat, similarityMat)
group <- lapply(strsplit(groupname, split = "_"), "[", 1)
group <- unlist(group)
name <- lapply(strsplit(groupname, split = "_"), function (x) x[length(x)])
name <- unlist(name)
lMatThr <- linkMat
dim(linkMat)
mzRTMSP <- paste(getPrecursorMZ(msp), getRT(msp), sep="/")
msp <- finalMSP
mzRTMSP <- paste(getPrecursorMZ(msp), getRT(msp), sep="/")
matchedHovMZRT <- match(name, mzRTMSP)
matchedHovMZRT
hoveredFeat <- msp[matchedHovMZRT[ind]]
ind <- 7
matchedHovMZRT[ind]
hoveredFeat <- msp[matchedHovMZRT[ind]]
hovFeat <- groupname[ind]
hovFeat
groupname[7]
hovFeat
connect <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
printInformationHover(colnames(simMatRT), finalMSP, ind = 7, lMatIndHover = c(206, 218:221), linkMatRT, simMatRT)
groupname <- colnames(simMatRT)
group <- lapply(strsplit(groupname, split = "_"), "[", 1)
group <- unlist(group)
name <- lapply(strsplit(groupname, split = "_"), function (x) x[length(x)])
name <- unlist(name)
lMatThr <- linkMatRT
mzRTMSP <- paste(getPrecursorMZ(msp), getRT(msp), sep="/")
matchedHovMZRT <- match(name, mzRTMSP)
hoveredFeat <- msp[matchedHovMZRT[ind]]
hovFeat <- groupname[ind]
hovFeat
connect <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
hovFeatlMatIndHover = c(206, 218:221)
connect <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
lMatIndHover = c(206, 218:221)
connect <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
connect
mzRTcon <- sapply(strsplit(connect, split="_"), function(x) x[3])
mzRTcon
hovFeat
connect
getLinkMatrixIndices( "att_0007_364.9163804/62.1957208", linkMatRT)
lMatIndHover = c(28:32)
connect <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
mzRTcon <- sapply(strsplit(connect, split="_"), function(x) x[3])
hovFeat
connect
hovFeat %in% connect
connect == hovFeat
connect[-which(connect == hovFeat)]
matchedConn <- match(mzRTcon, mzRTMSP)
matchedConn
connFeat <- msp[matchedConn]
connChar <- character()
degreeSimilarity <- similarityMatrix[hovFeat, ]
hovFeat
simMatRT[hovFeat, ]
degreeSimiilarity <- simMatRT[hovFeat, ]
length(connFeat)
connect
if (hovFeat %in% connect) connect <- connect[-which(connect == hovFeat)]
connect
connFeat
connFeat[1]
connectI
connect[1]
matchedConn <- match(mzRTcon, mzRTMSP)
matchedConn
connect <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
connect
if (hovFeat %in% connect) connect <- connect[-which(connect == hovFeat)]
sapply(strsplit(connect, split="_"), function(x) x[3])
mzRTcon <- sapply(strsplit(connect, split="_"), function(x) x[3])
matchedConn <- match(mzRTcon, mzRTMSP)
connFeat <- msp[matchedConn]
connChar <- character()
degreeSimilarity <- similarityMatrix[hovFeat, ]
degreeSimilarity <- simMatRT[hovFeat, ]
for (i in 1:length(connect)) {
connFeatI <- connFeat[i]
connectI <- connect[i]
degreeSimilarityI <- round(degreeSimilarity[connectI],3)
## degSimI <- degreeSimilarity[connFeatI]
newFeat <- paste0(connectI, " (", degreeSimilarityI, ", ",
getName(connFeatI), ", ", getMetaboliteName(connFeatI), ", ",
getMetaboliteClass(connFeatI), ")", "<br/>")
connChar <- c(connChar, newFeat)
}
connChar
connChar <- paste(connChar, collapse=" ")
paste0(hovFeat, " (", getName(hoveredFeat), ", ",
getMetaboliteName(hoveredFeat), ", ",
getMetaboliteClass(hoveredFeat), ") connects to ",
" <br/>", connChar)
printInformationHover <- function(groupname, msp = NULL,
ind, lMatIndHover, linkMatrixThreshold,
similarityMatrix) {
## get group and name from groupname argument
## groupname is a vector containing information about group and name,
## where group is the first element and name the last element separated by _
group <- lapply(strsplit(groupname, split = "_"), "[", 1)
group <- unlist(group)
name <- lapply(strsplit(groupname, split = "_"), function (x) x[length(x)])
name <- unlist(name)
lMatThr <- linkMatrixThreshold
if (is.null(msp)) {
## hoveredFeat
hoveredFeat <- groupname[ind]
## get connected features
connFeat <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
## remove hoveredFeat from connFeat
if (hoveredFeat %in% connFeat)
connFeat <- connFeat[-which(connFeat == hoveredFeat)]
if (length(lMatIndHover) > 0) {
connFeat <- paste(connFeat, collapse = " <br/>")
return(paste(c(hoveredFeat, "connects to", "<br/>", connFeat),
collapse = " "))
} else
return(paste(c(hoveredFeat, "does not connect to any feature"),
collapse = " "))
} else { ## if !is.null(msp)
## find hovered feature
mzRTMSP <- paste(getPrecursorMZ(msp), getRT(msp), sep="/")
matchedHovMZRT <- match(name, mzRTMSP)
hoveredFeat <- msp[matchedHovMZRT[ind]]
hovFeat <- groupname[ind]
## connected features
connect <- unique(as.vector(lMatThr[lMatIndHover, c("name1", "name2")]))
## remove duplicated hovFeat in connect
if (hovFeat %in% connect) connect <- connect[-which(connect == hovFeat)]
mzRTcon <- sapply(strsplit(connect, split="_"), function(x) x[3])
if (length(connect) == 0) {
return(paste0(hovFeat, " (", getName(hoveredFeat), ", ",
getMetaboliteName(hoveredFeat), ", ",
getMetaboliteClass(hoveredFeat), ") ",
"does not connect to any feature"))
} else {
matchedConn <- match(mzRTcon, mzRTMSP)
connFeat <- msp[matchedConn]
connChar <- character()
degreeSimilarity <- similarityMatrix[hovFeat, ]
for (i in 1:length(connect)) {
connFeatI <- connFeat[i]
connectI <- connect[i]
degreeSimilarityI <- round(degreeSimilarity[connectI],3)
## degSimI <- degreeSimilarity[connFeatI]
newFeat <- paste0(connectI, " (", degreeSimilarityI, ", ",
getName(connFeatI), ", ", getMetaboliteName(connFeatI), ", ",
getMetaboliteClass(connFeatI), ")", "<br/>")
connChar <- c(connChar, newFeat)
}
connChar <- paste(connChar, collapse=" ")
return(paste0(hovFeat, " (", getName(hoveredFeat), ", ",
getMetaboliteName(hoveredFeat), ", ",
getMetaboliteClass(hoveredFeat), ") connects to ",
" <br/>", connChar))
}
}
}
shinyCircos(similarityMatrix = similarityMat, msp = finalMSP)
finalMSP[1:10]
shinyCircos(similarityMatrix = similarityMat[1:10, 1:10], msp = finalMSP[1:10])
shinyCircos(similarityMatrix = similarityMat[1:10, 1:10])
BiocInstaller::biocLite("RUnit")
BiocInstaller::biocLite("roxygen2")
getwd()
setwd("/home/thomas/R/MetCirc/")
library(roxygen2)
roxygenise()
testAllocatePrecursor2MZ <- allocatePrecursor2mz(sd01_outputXCMS, sd02_deconvoluted)
data("sd02_deconvoluted.RData")
library(MetCirc)
data("sd02_deconvoluted.RData")
data("sd02_deconvoluted")
data("sd01_outputXCMS")
allocatePrecursor2mz <- function(sd01, sd02, kNN = 10, mzCheck = 1,
rtCheck = 30, mzVsRTbalance = 10000, splitPattern = "_", splitInd = 2) {
## Multiplicator for mz value before calculating the (euclidean) distance
## between two peaks high value means that there is a strong weight on the
## dev m/z value mzVsRTbalance
if (kNN <= 0) stop("kNN has to be > 0")
if (mzCheck <= 0) stop("mzCheck has to be > 0")
if (rtCheck <= 0) stop("rtCheck has to be > 0")
if (mzVsRTbalance <= 0) stop("mzVsRTbalance has to be > 0")
if (!all(sort(colnames(sd02)) == c("intensity", "mz", "pcgroup_precursorMZ", "rt")))
stop("colnames(sd02) have to be 'mz', 'rt', 'intensity', 'pcgroup_precursorMZ' ")
colNamesSd01 <- colnames(sd01)
if (!all(c("mz", "rt", "npeaks", "isotopes", "adduct", "pcgroup") %in% colNamesSd01))
stop("colnames(sd01) have to have 'mz', 'rt', 'npeaks', 'isotopes', 'adduct', 'pcgroup'")
precursor <- sd02[, "pcgroup_precursorMZ"]
## isolated mz values from e.g. pcgroup_precursorMZ column in
## sd02_deconvoluted
uniquePrecursor <- cutUniquePreMZ(precursor,
splitPattern = splitPattern, splitInd= splitInd)
## create finalCluster, which is the data.frame to store data
finalCluster <- matrix(nrow = length(uniquePrecursor), ncol = dim(sd01)[2] + 7)
colnames(finalCluster) <- c(colnames(sd01), "Metabolite Name",
"Adduct ion name", "Spectrum reference file name",
"check RT", "dev RT", "check mz", "deviation m/z")
colnames(finalCluster)[which(colnames(finalCluster)=="mz")] <- "average mz"
colnames(finalCluster)[which(colnames(finalCluster)=="rt")] <- "average rt"
finalCluster <- as.data.frame(finalCluster)
uniquePreMZ <- unique(precursor)
## LOOP WHICH WRITES TO finalCluster
for (i in 1:length(uniquePrecursor)) {
sd02mz <- uniquePrecursor[i]
sd02mz <- as.numeric(sd02mz)
sd01mz <- sd01[, "mz"]
sd01mz <- as.character(sd01mz)
sd01mz <- as.numeric(sd01mz)
devmzOld <- devmz <- abs(sd02mz - sd01mz)
## use only kNN m/z dev
sortDevMz <- sort(devmz)[1:kNN]
## get indices in sd01 of the smallest deviances
indSortDevMZOld <- indSortDevMZ <- match(sortDevMz, devmz)
## truncate devmz such that it only includes kNN m/z deviances
devmz <- devmz[indSortDevMZ]
## check if devmz is in tolerated distance
if (any(devmz <= mzCheck)) {
## truncate such that indSortDevMZ includes only indices and
## devmz only m/z within the tolerance value
indSortDevMZ <- indSortDevMZ[devmz <= mzCheck]
devmz <- devmz[devmz <= mzCheck]
ToleranceCheckMZ <- TRUE
} else {
print (c(i,"Deviation of m/z is greater than tolerance value.
I won't truncate the kNN."))
devmz <- devmz
ToleranceCheckMZ <- FALSE
}
## calculate fake rt from sd02 (from fragment rt values)
ind <- which(uniquePreMZ[i] == precursor)
sd02rt <- sd02[ind, "rt"]
sd02rt <- mean(sd02rt)
## determine rt values from sd01
sd01rt <- sd01[indSortDevMZ, "rt"]
sd01rt <- as.character(sd01rt)
sd01rt <- as.numeric(sd01rt)
devrt <- abs(sd02rt - sd01rt)
if (any(devrt <= rtCheck)) {
## truncate devmz and devrt that it is included in the tolerance
## value
devmz <- devmz[devrt <= rtCheck]
devrt <- devrt[devrt <= rtCheck]
ToleranceCheckRT <- TRUE
objective <- mzVsRTbalance * devmz + devrt
} else {
print(c(i, "Deviation of rt is greater than tolerance value.
I won't use rt as a criterion."))
ToleranceCheckRT <- FALSE
objective <- devmz ## use only devmz
}
## find smallest value for objective function
minInd <- which.min(objective)
## get index in sd01
minInd <- which(devmz[minInd] == devmzOld)
## write to finalCluster:
## get the entry of sd01 with the smallest value
XCMS <- sd01[minInd,]
replaceInd <- !is.na(match(colnames(finalCluster), colNamesSd01))
finalCluster[i, replaceInd] <- as.vector(as.matrix(XCMS[replaceInd]))
finalCluster[i, "average rt"] <- sd02rt
finalCluster[i, "average mz"] <- uniquePrecursor[i]
finalCluster[i, "Metabolite Name"] <- "Unknown"
finalCluster[i, "Adduct ion name"] <-
if (nchar(as.character(XCMS[, "adduct"]) == 0)) "Unknown" else XCMS[,"adduct"]
finalCluster[i, "Spectrum reference file name"] <- "Unknown"
##x <- XCMS[,which(colnames(XCMS) == "1"):which(colnames(XCMS) == "183")]
##x <- as.matrix(x)
##x <- as.vector(x)
##entry[, which(colnames(entry)=="1"):which(colnames(entry)=="183")] <- x
finalCluster[i, "check RT"] <- ToleranceCheckRT
finalCluster[i, "dev RT"] <- sd02rt - as.numeric(as.character(XCMS[,"rt"]))
finalCluster[i, "check mz"] <- ToleranceCheckMZ
finalCluster[i, "deviation m/z"] <- sd02mz - as.numeric(as.character(XCMS[,"mz"]))
}
return(finalCluster)
}
testAllocatePrecursor2MZ <- allocatePrecursor2mz(sd01_outputXCMS, sd02_deconvoluted)
is.data.frame(testAllocatePrecursor2MZ)
dim(testAllocatePrecursor2MZ)
colnames(testAllocatePrecursor2MZ)
printInformationHover(
groupname = groupname, msp = NULL, ind = ind,
lMatIndHover = linkMatIndsHover,
linkMatrixThreshold = linkMat_thr,
similarityMatrix = orderedSimMat)
data("idMSMStoMSP", package = "MetCirc")
data("binnedMSP", package = "MetCirc")
binnedMSP <- binnedMSP[c(1:20, 29:48, 113:132, 240:259),]
similarityMat <- createSimilarityMatrix(binnedMSP)
## order similarityMat according to mz
simMat <- createOrderedSimMat(similarityMat, order = "mz")
groupname <- rownames(simMat)
linkMat_thr <- createLinkMatrix(simMat, 0.9)
ind <- 19
linkMatIndsHover <- getLinkMatrixIndices(groupname[ind], linkMat_thr)
printInformationHover(
groupname = groupname, msp = NULL, ind = ind,
lMatIndHover = linkMatIndsHover,
linkMatrixThreshold = linkMat_thr,
similarityMatrix = orderedSimMat)
ind <- 18
linkMatIndsHover <- getLinkMatrixIndices(groupname[ind], linkMat_thr)
printInformationHover(
groupname = groupname, msp = NULL, ind = ind,
lMatIndHover = linkMatIndsHover,
linkMatrixThreshold = linkMat_thr,
similarityMatrix = orderedSimMat)
printInformationHover(
groupname = groupname, msp = NULL, ind = 20,
lMatIndHover = linkMatIndsHover,
linkMatrixThreshold = linkMat_thr,
similarityMatrix = orderedSimMat)
printInformationHover(
groupname = groupname, msp = NULL, ind = 21,
lMatIndHover = linkMatIndsHover,
linkMatrixThreshold = linkMat_thr,
similarityMatrix = orderedSimMat)
linkMat_thr <- createLinkMatrix(simMat, 0.75)
ind <- 18
linkMatIndsHover <- getLinkMatrixIndices(groupname[ind], linkMat_thr)
groupname = groupname, msp = NULL, ind = 21,
printInformationHover(
groupname = groupname, msp = NULL, ind = ind,
lMatIndHover = linkMatIndsHover,
linkMatrixThreshold = linkMat_thr,
similarityMatrix = orderedSimMat)
ind <- 18
simMat <- createOrderedSimMat(similarityMat, order = "mz")
groupname <- rownames(simMat)
linkMat_thr <- createLinkMatrix(simMat, 0.75)
ind <- 18
linkMatIndsHover <- getLinkMatrixIndices(groupname[ind], linkMat_thr)
printInformationHover(
groupname = groupname, msp = NULL, ind = ind,
lMatIndHover = linkMatIndsHover,
linkMatrixThreshold = linkMat_thr,
similarityMatrix = orderedSimMat)
remove.packages("MetCirc", lib="~/R/x86_64-pc-linux-gnu-library/3.3")
install.packages("~/R/MetCirc_0.99.2.tar.gz", repos = NULL, type = "source")
library(MetCirc)
similarityMat
binnedMSP
biocLite("pRoloc")
library(BiocInstaller)
biocLite("pRoloc")
biocLite("biomaRt")
biocLite("biomaRt")
biocLite("biomaRt")
biocLite("MSnbase")
biocLite("pRoloc")
biocLite("rgl")
biocLite("rgl")
biocLite("pRoloc")
library(pRoloc)
exprs <- cbind(names = rownames(binnedMSP), binnedMSP)
fData <- data.frame(names = rownames(binnedMSP), class = numeric(length(rownames(binnedMSP))))
fData
binnedMSP <- binning(msp = finalMSP, tol = 0.01, group = species, method = "median")
species <- c(rep("att", length = length(finalMSMS_att)), rep("obt", length = length(finalMSMS_obt)), rep("clev", length = length(finalMSMS_clev)))
binnedMSP <- binning(msp = finalMSP, tol = 0.01, group = species, method = "median")
MSMS_att <- MSMS[MSMS[,4] %in% names(mm72WOS[mm72WOS[,1] == 1, 1]), ]
finalMSMS_att <- convert2MSP(MSMS_att, splitPattern = "_", splitInd = 1)
MSMS_obt <- MSMS[MSMS[,4] %in% names(mm72WOS[mm72WOS[,2] == 1, 1]), ]
finalMSMS_obt <- convert2MSP(MSMS_obt, splitPattern = "_", splitInd = 1)
MSMS_clev <- MSMS[MSMS[,4] %in% names(mm72WOS[mm72WOS[,3] == 1, 1]), ]
finalMSMS_clev <- convert2MSP(MSMS_clev, splitPattern = "_", splitInd = 1)
finalMSP <- combine(finalMSMS_att, finalMSMS_obt)
finalMSP <- combine(finalMSP, finalMSMS_clev)
MSMS_att
